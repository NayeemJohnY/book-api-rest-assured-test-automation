package tests;

import static testUtils.LoggingMatcher.log;

import io.qameta.allure.Description;
import io.qameta.allure.Epic;
import io.qameta.allure.Feature;
import io.qameta.allure.Severity;
import io.qameta.allure.SeverityLevel;
import io.restassured.RestAssured;
import io.restassured.http.ContentType;
import org.hamcrest.Matchers;
import org.testng.annotations.BeforeTest;
import org.testng.annotations.Test;
import pojos.Book;
import testUtils.Assertion;

/** Test cases for deleting books via the API. */
@Epic("Book Management")
@Feature("Delete Book")
@Severity(SeverityLevel.MINOR)
public class TS04_DeleteBook extends BaseTest {

  private int bookId;

  /** Creates a book before running delete book tests. */
  @BeforeTest(alwaysRun = true)
  @Description(
      "Creates a set of books before running delete book tests to ensure data is available.")
  public void createBookBeforeDeleteBookTest() {
    Book book = new Book("Delete API Test Book Title", "Delete API Test Book Author");
    Book responseBook =
        retryRequest(
                () ->
                    RestAssured.given()
                        .auth()
                        .oauth2(USER_AUTH_TOKEN)
                        .contentType(ContentType.JSON)
                        .body(book)
                        .when()
                        .post())
            .then()
            .statusCode(201)
            .extract()
            .as(Book.class);
    Assertion.assertNotNull(responseBook.getId(), "Book ID should be generated by the server");
    Assertion.assertEquals(responseBook.getTitle(), book.getTitle(), "Book title should match");
    Assertion.assertEquals(responseBook.getAuthor(), book.getAuthor(), "Book author should match");

    bookId = responseBook.getId();
  }

  /** Should return 401 when no auth token is provided on delete. */
  @Test(groups = {"negative", "regression"})
  @Description(
      "Attempts to delete a book without authentication and expects a 401 Unauthorized error.")
  public void testShouldReturn401WhenNoAuthTokenProvidedOnDelete() {

    RestAssured.given()
        .pathParam("bookId", bookId)
        .when()
        .delete("/{bookId}")
        .then()
        .statusCode(401)
        .body("error", log(logger, Matchers.equalTo("Unauthorized. No token provided.")));
  }

  /** Should return 403 when user auth token is provided on delete. */
  @Test(groups = {"negative", "regression"})
  @Description(
      "Attempts to delete a book with a user token (not admin) and expects a 403 Forbidden error.")
  public void testShouldReturn403WhenUserAuthTokenIsProvidedOnDelete() {
    RestAssured.given()
        .auth()
        .oauth2(USER_AUTH_TOKEN)
        .pathParam("bookId", bookId)
        .when()
        .delete("/{bookId}")
        .then()
        .statusCode(403)
        .body("error", log(logger, Matchers.equalTo("Forbidden. Admin access required.")));
  }

  /** Should delete the book when book ID is valid. */
  @Test(groups = {"smoke", "regression"})
  @Description(
      "Deletes a book using a valid admin token and verifies successful deletion (204 No Content).")
  public void testShouldDeleteBookWhenBookIdIsValid() {
    RestAssured.given()
        .auth()
        .oauth2(USER_ADMIN_TOKEN)
        .pathParam("bookId", bookId)
        .when()
        .delete("/{bookId}")
        .then()
        .statusCode(204);
  }

  /** Should return 404 when the book is already deleted or does not exist. */
  @Test(
      groups = {"negative", "regression"},
      dependsOnMethods = "testShouldDeleteBookWhenBookIdIsValid")
  @Description(
      "Attempts to delete a book that is already deleted or does not exist and expects a 404 Not Found error.")
  public void testShouldReturn404WhenBookIsAlreadyDeletedOrNotExists() {
    RestAssured.given()
        .auth()
        .oauth2(USER_ADMIN_TOKEN)
        .pathParam("bookId", bookId)
        .when()
        .delete("/{bookId}")
        .then()
        .statusCode(404)
        .body("error", log(logger, Matchers.equalTo("Book not found")));
  }
}
